#pragma once

void study(void)
{
	//预备阶段
	if (1)
	{
		/*
			以往误区：	编译器是C3带我们说的，其实这种说法不准确，正确说法是集成开发环境
						编译、调试等等，都是集成开发环境的一部分功能，老师只是说顺口了

			导航：		代码的书写顺序，与课件的顺序一致

			补充：		生成项目后，左侧文件夹一样的东西是方便分类用的，可随意删除、修改名称、添加（右击项目--添加--新建筛选器）
						只要方便分类，怎么样都行，默认不修改的话，就是头文件、源文件、资源文件等

						头文件的添加，头文件相当于在预编译期，就把该头文件的所有内容复制粘贴到程序中
						假设头文件添加得太多太多（几乎不太可能），那么编译消耗的时间将会增加，因为预编译时要不断进行复制粘贴

						system("pause"); 只是对windows有效， 用getchar 也是卡住，更通用

		*/
	}
	//登陆界面
	while (0)
	{
		//设置光标位置
		if (1)
		{
			/*
				设置光标位置要用到SetConsoleCursorPosition 与控制台窗口句柄，（句柄获取方式：GetStdHandle(STD_OUTPUT_HANDLE)）

				光标不仅是指定从哪开始打印，scanf输入也是由光标指定的位置输入

				注意XY 行列 的对应关系，写参数时也要注意。（看代码更好理解）
			*/
		}
		//登陆界面相关
		if (2)
		{
			/*
				首先：
					首先最开始就是打印主菜单及边框了
					主菜单会有各种选项指令
					打印完利用GotoXY跳转光标到输入指令的位置
				其次：
					指令选项1，是登陆界面，在主菜单下方添加三行，利用Goto从输入指令位置转到主菜单栏下方
					登录界面也需要光标转到，输入用户名及密码的位置
					输入之后，会有失败提示界面，成功界面，在登录界面的下方两行打印
					失败之后要重新输入指令，光标又跳转到输入指令位置
				其次：
					注册界面：与登陆界面代码几乎一样，只是把登录改成注册而已
				其次：
					游客登录、退出、有误界面
					打印前要用 system("cls"); 清屏，防止此前其他操作的打印有残留
					在主菜单栏下打印信息
			*/
		}
		//用户信息存入文件
		if (3)
		{
			/*
				保存用户信息到文件中

				首先：
						用户信息结构体声明
						打开文件--写入文件--关闭文件
				补充要点：
						每个文件都能存在一个同名的结构体，作用域就是它所在的文件，同个文件下不能有两个同名结构体
						有fopen_s就一定要fclose 否则会有fopen_s的13错误码，下次fopen_s就用不了了
						fwrite(user, sizeof(struct User), 1, pFile);结构体user向文件中文件指针 pFile 指向的位置写入 1 组大小为 sizeof(struct User) 的数据
						fopen_s(&pFile, "user.dat", "a");			"user.dat" 我们随便起什么名，什么后缀都可以，只要我们自己知道就行 “a” 是接着写，没有对应文件，就创建对应文件
			*/
		}
		//用户信息查询
		if (4)
		{
			/*
				首先：
						此前已经把注册过的信息存到一个文件中了
						查询时，我们只需要，读取那个文件，进行遍历
						将文件中的信息与我们要查询的人进行比较
						找到了说明注册过，没找到说明没注册过
						函数有返回值 bool 类型 （需要头文件stdbool）
				其次：
						本次用 循环读取文件
						while (!feof(pFile))	feof会依次从给的地址开始向后遍历，没到结尾返回0，遍历到结尾返回1
						信息比较使用的函数：strcmp
						找到 名字 与 密码 都对应的 返回true ，没找到 返回 false
				其次：
						还有一个只查询名字的，逻辑与上面的一样，只不过不对密码进行匹配

				最后：
						我已测试过我的代码可以正常运行查找
			*/
		}
		//用户菜单依次实现
		if (5)
		{
			/*
				首先：
						把前面写的登陆界面相关的函数等，用逻辑串起来，形成一个连贯的功能
						将登陆函数bool Login(void) 改为有返回值的
				其次：
						先是登录的选项，输入1，后，跳转到输入用户名与密码界面，且光标跟着动
						输入用户与密码后，判断与后台的用户信息是否匹配，匹配的话 返回true，并跳转到对应界面，
						没有匹配的则跳转光标重新输入指令，（此处我加了个逻辑，就是将此前的指令打印的残留消除，看着更美观）
				其次：
						选项2：注册界面 与上面类似，看代码即可
				其次：
						选项3：游客登陆 选项4：退出系统
				最后：
						输入指令错误的问题：
						
						接收指令的int iOrder 是整形，假设客户输入字符，会发现程序卡住，不能输入了
						原因是：字符型不能被装到整形中，会一直存在于缓冲区（类似内存条），下次循环来读缓冲区，还是这个字符型，再一轮还是
						这样这个字符型就进退两难了，不能被存进int 读不出来我们就没办法继续输入
						解决办法：清空缓冲区，上百度找，老师的第一种在VC有效，VS就没用了
						第二种：while ((c = getchar()) != '\n' && c != EOF);	
								清空缓冲区，避免字符型输入导致卡住，这种方式也有弊端，比如清空过程中，又不断极快速输入，会导致问题

						switch中不能直接声明定义，但加上{}就可以了


			*/
		}
	}
	//管理界面
	while (0)
	{
		//先谈谈我遇到的大问题
		if (6)
		{
			/*
				视频里：老师用了以下代码，调用其它文件中的变量，我也一样，但是产生了不同的结果
						struct User
						{
							char name[15];
							char Key[20];
						};
						extern struct User g_user;
						老师的是能够正常引用，而我的却提示“struct”类型重定义
				我一度怀疑是我的编译器问题，但最终对比老师的代码，我似乎找到了我自己更严重的问题

				我与老师代码的不同点：
						此前：
						我将统筹函数分别写到 login.h 和 manage.h 下
						且这俩.h还有main.c里 都包含了公共头文件common.h（这里放着俩.h常用到的头文件的集合）尽管都写了 #pragma once 
						写manage.h时，将GoToXY的声明写过来，写manage.c时将GoToXY的定义也从login.c复制过来了
						然后发现错误的地方来了，我将上面提到的代码写下来运行就报错了

						更正：我进行一一排查
						首先：统筹函数的声明放到哪，只要其中一个文件有定义就可以了，关键的是main.c想要用，必须确保包含了这俩统筹函数所在的头文件，或者直接把他俩放到自己的文件下
						其次：common.h被谁包含都没有问题，俩.h和main.c一起包含都没问题

						出错了：GoToXY的声明复制到manage.h下没问题，manage.c里GoToXY的声明就不用再复制了，
								分析原因：.h中的函数声明，似乎会去所有.c中寻找定义，而并非跟自己同名的.c，所以定义只要一个就够了

						再次出错：main.c将 "login.h" 和 "manage.h" 都包含时，最开始的问题就出现了
								分析原因：	包含头文件本质上是将 该头文件的所有内容在预编译期复制到此处
											那么俩一摸一样的结构体的类型就出现了，就会提示类型重定义
											只要main.c里不同时包含俩头文件就可以，（很好奇#pragma once 对它不起作用）
								分析原因：
											很可能是结构体分两部分来的，一个是类型，有了类型才能声明变量，然后才能定义
											正常情况下的一般变量，都只有声明，定义两部分
											#pragma once对多个文件的重复声明有效，对类型无效，因为声明要基于类型来的（仅个人推测）
											#pragma once对重复定义也是无效的
						反思：				
											头文件的作用在于编译时，会在#include<*.h>位置处展开
											.c文件与.h文件的对应关系不是按名字来的（我是傻逼），而是看那个.c文件包含的.h
											比如 A.c 包含了 A.h 那A.c就根据A.h的声明来写代码，同时B.c也包含了A.h
											那B.c也只能按照A.h来写代码

						再反思：				那俩统筹函数声明放到那3个位置都可以的原因，
											不论放到哪，它都是声明，只要这么多文件中有它的定义，就能用这个函数了
											但是如果阻断main.c与声明之间的联系，不包含任何头文件，统筹函数放到除main.c外的不论哪里，main.c都无法使用了
											能放到其它地方，main.c想要使用，必须确保包含了这俩统筹函数所在的头文件，或者直接把他俩放到自己的文件下
								
								
			*/
		}
		//经过上一课的教训，我总结了这次多文件的包含调用流程
		if (7)
		{
			/*
				要点：	主要围绕 统筹函数来说
						
				首先：
						main.c要使用统筹函数，就必须确保包含了这俩统筹函数声明所在的头文件，或者直接把他俩放到自己的文件下
						显然因为结构体引用原因，俩.h不能同时被main.c包含（上节课教训），那么把声明放到公共头文件或main.c下即可
				其次：
						main.c有办法包含了俩统筹函数声明，就能够调用统筹函数，俩统筹函数定义分别在俩 .c文件里
						而那俩 .c文件 则包含了对应的 .h，这样一来，统筹函数定义逻辑中所有需要的函数等等，都能通过那俩.c包含的.h找到声明使用
						而main.c只需要使用统筹函数即可，而不必包含俩 .h文件
						
				总结：
						实现了main.c--(登录/管理)统筹函数--(登录/管理)函数定义的 .c文件--(登录/管理)定义逻辑里所需的函数与定义--(登录/管理)所需函数的.h文件
						也可以把该结构体声明放到common.h 公共头文件下 就完美解决我遇到的问题了，这问题也帮助我思考了很多，更了解了

						其实老师的那句话就说的很明白了：每个文件都能存在一个同名的结构体声明，作用域就是它所在的文件，同个文件下不能有两个结构体声明
						就是别让一个文件下出现俩声明，但是教训让我更理解了头文件的包含
			*/
		}
		//管理界面相关 这次菜单很多，可能要分好几批
		if (8)
		{
			/*
				首先：
						打印管理界面的主菜单，涉及到统筹函数调用的逻辑，引用别的文件变量的问题，请看上一次笔记，再上一次的太多了，实在想不起来再看
						还有就是全局变量 g_user 的使用是个好点子 ，让它在登录界面就当作跳转到管理界面的过度，就能直观的知道是谁登录的
				其次：
						退出系统界面、指令输入失败界面，
						这俩的逻辑与登陆的那一边的很类似，清屏--重画主菜单--指定光标--打印提示信息--指定光标或倒计时
						看代码就很好理解，另外要注意的是：输入指令有误那里的 清空缓冲区的方法及为何要清空的原因
				其次：
						添加学生界面，及成功添加的提示
						添加学生：清屏--重绘主菜单--指定光标--打印添加界面--指定光标：输入学生信息
						成功提示：指定光标--打印--光标转到输入指令位置
						成功提示 是 学生添加 的补充附属，所以不必清零
				其次：
						剩下的就是双向链表有关知识比较多得了
						语言不好描述，但似乎对于链表我还记得清楚，不吃力，
						偶尔有些地方逻辑上有点阻塞，但还是能够理解，并且留了注释
						而且很多功能我能够拓展开，其实大部分代码重复率很高，就是不断打印
				总结：
						除了上述提到的外，剩下的课的内容笔记，请查看源代码注释，注释的比较明白了
			*/
		}
	}
	
}